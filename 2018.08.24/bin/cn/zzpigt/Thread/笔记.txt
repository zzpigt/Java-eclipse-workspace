
【词汇表】

 1. 应用程序 (application)
  为了完成特定的任务, 用某种语言编写的一段指令集合(一组静态的代码)

 2. 进程
  运行中的程序, 操作系统调度与资源分配的一个独立单位

 3. 多进程
  可以同时打开多个进程
 好处: 更好的利用CPU资源

 4. 线程
  程序执行的最小单元,
  一个进程可以有一个或者多个线程

 5. 多线程
 好处: 更好的抢占CPU资源

 6. 并发
  通过CPU调度算法,让用户看上去是同时进行,其实从CPU操作层面上不是真正的同时

 7. 并行
  多个CPU实例或者多台机器同时做一段处理逻辑,是真正的同时


【java中如何实现线程】

 1. 继承Thread类, 重写run方法, 构造对象调用start方法启动

 2. 声明实现 Runnable 接口的类, 实现run方法, 创建 Thread 时作为一个参数来传递, 并 start

【线程的控制方法】

 1. sleep

   睡眠
   指定睡眠的时间 ,单位是毫秒
   静态方法,和调用的对象无关

 2. yield
 
   让步
   使得当前线程暂时退出CPU, 可能会让其他线程获得执行权
   静态方法,和调用对象无关


 3. interrupt
  
   中断,
   这个方法不是真的直接中断线程,而是仅仅改变了线程的一个标志位
   会导致有超时参数的方法进入异常状态(如sleep)
   没有超时参数的方法可以用 Thread.interrupted 来判断这个标志位


 4. join

   等待该线程终止


 5. setDaemon
   
   守护线程

 6. setPriority

   线程的优先级
   线程默认优先级是和它的父线程一致


【线程的状态】

 可以通过 getState() 获得线程的状态

 1. New 新创建
  当new创建了一个新线程对象时, 该线程还没有开始运行
  处于这个状态的线程还没有开始执行run中的代码  

 2. RUNNABLE 可运行
  一旦调用了start方法, 线程就处于runnable状态
  一个可运行的线程可能正在运行也可能没有
  这取决于操作系统给线程提供运行的时间

  一旦一个线程开始运行, 它不必始终保持运行
  运行中的线程被中断, 目的是为了让其他线程获得执行机会
  抢占式调度系统给每一个可运行线程一个时间片来执行任务
  当时间片用完,操作系统就会剥夺线程的执行权, 给别的线程执行机会
 
  当选择下一个线程时, 操作系统会考虑一下线程的优先级  

 3. BLOCKED 被阻塞

  当一个线程试图获取一个对象锁, 而这个对象被其他线程锁持有
  则当其他所有线程释放该锁, 并且调度器允许本线程持有它的时候
  该线程变回非阻塞状态

 4. WAITING 等待
  
  当线程等待另一个线程通知调度器一个条件时, 自己就会进入等待状态

 5. TIMED_WAITING 计时等待
 
  方法中含有一个超时参数, 调用的话就会导致线程进入计时等待状态
  这一状态会保持到超时期满, 或收到适当的通知

 6. TERMINATED 被终止

  线程终止的条件
  1. run方法正常退出导致死亡
  2. 因为一个没有捕获的异常导致run方法异常终止而死亡
 

【线程同步】

 通过人为的控制和调度, 保证共享资源的多线程访问成为线程安全, 保证结果的准确
 
【synchronized 用法】

 1. 修饰方法

   同步成员方法 - 一个对象一把锁, 保护成员属性的线程安全
 
   同步静态成员方法 - 一个类一把锁, 保护静态属性的线程安全

 2. 修饰代码块

   	synchronized(锁对象){

	}

	只有第一个拿到了锁的线程才允许执行代码块, 其他线程在外等待
	
	好处是可以减少锁的范围, 提高程序的性能.

 * 好的程序要在保证结果准确性 再提高性能.


 #3. 死锁 

  尽可能不要在持有一把锁的情况下去抢另一把锁 

【线程间通信】

  生产者消费者模型

  wait/notify

  1. wait和notify都是Object类中的方法
  2. wait作用是放弃当前的锁, 使自己当前的线程进入waiting状态
  3. notify作用是唤醒waiting状态下的线程
  4. wait notify synchronized, 必须针对于同一对象
  5. wait notify 只能在 synchronized 范围内生效
  6. wait前必须有个if








