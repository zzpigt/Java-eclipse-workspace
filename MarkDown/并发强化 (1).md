# 并发强化
这里学习API中的几个方法函数

## 【Timer和TimerTask】
***Timer***其实就是一个调度器，安排后台线程执行的任务，主要方法可以说只有3个，简单的**cancel()** 和 **purpe()**，分别是取消当前的计时器和移除所有的已经取消的任务。而最重要的方法是**schedule()/scheduleAtFixedRate()**。
***TimerTask***主要就是为了实现 **run()** 方法，这个类作为 ***Timer*** 的一个参数，可以自己来定义 **run** 里面的内容，这也是定时器的主要实现内容！！

```java
//隔两秒输出boom！！，之后每隔一秒输出一次
new Timer().schedule(new TimerTask(){
    @Override
	public void run() {
		System.out.println("boom!!");
	}
},2000,1000);
```
而 **schedule** 和 **scheduleAtFixedRate** 的不同在于前者是通过当前时间（在任务执行前得到）+时间片计算下一次执行的时间，后者是按固定的速率执行，是通过执行时间（也就是计算出现在应该执行的时间）+时间片计算下一次执行的时间。他们的使用方法是一样的。

>比如： **schedule** 时间片是5s，那么理论上会在5，10，15，20这些时间被调度，但是如果由于某些时间CPU被征用导致未被调度，假如第一次等到8s才被调度，那么 **schedule** 方法计算出的下一次时间应该是第13s而不是原先的第10s。
>而 **scheduleAtFixedRate** 方法是每次理论计算出下一次需要调度的时间用以排序，若第一次在第8s被调度，那么计算出的应该是第10s，可以尽量减少漏掉调度的情况（20s内， **schedule** 才调度3次，而 **scheduleAtFixedRate** 调度4次）。

## 【Callable、Future和FutureTask】
创建线程的方式有两种，一种是继承Thread类，另一种是实现Runnable接口。而这两种方式都有一个缺陷就是：在执行完任务后无法获得执行结果。
如果需要获得子线程的执行结果，就必须通过共享变量或者使用或者线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到执行结果。
**Callable**是一个泛型接口，实现的 **call()** 函数返回类型就是传递进来的泛型，里面实现内容就是任务的内容，最后返回执行结果。
而具体怎么使用 **Callable** 可以去看API，（待续。。）

```java
//自己实现Callable类，重写call()方法，然后配合FutureTash使用，可以等到子线程走完，
//返回结果，主线程输出这个结果
public static void main(String[] args) {
		MyCallable<String> myCallable = new MyCallable<>();
		try {
			FutureTask<String> ft = new FutureTask<>(myCallable);
			new Thread(ft).start();
			Thread.sleep(1000);
			if(ft.isDone()) {
				System.out.println("子线程关闭了！！");
			}else {
				System.out.println("子线没有关闭！！");
			}
			String str = ft.get();
			System.out.println(str);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	static class MyCallable<String> implements Callable<String>{
		@Override
		public String call() throws Exception {
			Thread.sleep(5000);
			String str = (String) "fuck";
			return str;
		}
	}
```
