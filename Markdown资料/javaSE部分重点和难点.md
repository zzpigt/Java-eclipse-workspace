这里说的这些什么重点和难点，也就是初期学习过程中不容易记住的知识点。真正的难点是对每个知识点的深挖，像JVM就够我们‘痛苦’很久。所以，这写的也就是给我自己留个能回头看看的地方。
**JAVA** 的优势只要记住跨平台和垃圾回收，也就JVM和GC。现在安装它的开发工具包非常方便， **JDK** 里面就包含了 **JRE** ，也包含了 **JVM**，所以安装好了JDK，只要配置好环境变量就可以运行java程序。
## 语法基础知识点小结
JAVA中的数据类型，都知道分为基本类型和引用类型，捡容易的基本类型来说：
* byte（1个字节）&nbsp;&nbsp;&nbsp;&nbsp;short（2个字节） &nbsp;&nbsp;&nbsp;&nbsp;int（4个字节）&nbsp;&nbsp;&nbsp;&nbsp;  long（8个字节）
* boolean(4/1个字节) &nbsp;&nbsp;&nbsp;&nbsp;char(2个字节)  &nbsp;&nbsp;&nbsp;&nbsp; float（4个字节）&nbsp;&nbsp;&nbsp;&nbsp;double(8个字节)

像String这样的引用类型很多很多，就不阐述了，这里还需要记住的是基本类型之间的转换，boolean不参与类型转换，其它7种从小到大的顺序：`byte/short/char --> int --> long --> float --> double`。只能小类型转成大类型。

**运算符** 优先级这些说记住也不可能，这时你能记住，不经常使用后面也就忘了，所以我对自己的要求是不强求。知道基本的使用就行，比如最基础的 ***前加（++a）*** 和 ***后加（a++）*** ，这些在面试也许都会问的基础肯定是必须知道的。

其它的 **选择结构** 和 **循环结构** 这些在编程不可避免的经常使用，也就不需赘述，熟的不能再熟了，想练习的话，做做[leetcode](https://leetcode.com/)的算法题吧。

最后说一下 **数组** 和 **函数** ：****数组*** 也是一种引用类型，这个点主要需要记住的是它的内存存储形式【栈：引用（队中对象的地址）；堆：对象】，基础语法记住一个不常见的静态初始化`int[] a = new int[]{1,2,3};`就行，其它在日常编程中经常使用； ***函数*** 也就是常说的方法，这个真的只可意会。

## 面向对象
一提这个碧池，肯定会想起来封装、继承和多态，跟条件反射一样。**OOP** 就像是嘴里嚼了好几年的口香糖，那味道吐掉也附在口腔。当然，只要你还接触编程，那么你就不可能吐出来。下面总结都是概念，很枯燥，但是也非常重要，建议是理解的基础上记住它。

> 除了 **OOP** ，还有 **OOA** [面向对象分析] 和 **OOD** [面向对象设计]

关于面向对象的概念，网上、书上非常非常多的经典的解释，我这里只说我理解的一角。
### 封装
隐藏成员变量和成员方法，以及成员方法的实现过程。最基本的概念就是 ***类*** 和 ***对象***。
隐藏的方法就是四个访问修饰符【public，protected，[default]，private】
访问修饰符|本类|包内|子类|包外其他类
---|---|---|---|---|
public|√|√|√|√
protected|√|√|√|X
[default]|√|√|X|X
private|√|X|X|X

**this** 【关键字】
1. 指的是调用这个变量或者方法的对象本身
2. 出现在构造器中时，指的是另一个构造器（必须出现在第一行）

### 继承
就是把多个类中相同的成员抽取出来放在一个类中，再使用extends关键字使他们产生联系。提高了代码的可重用性，以后的修改也会更灵活。当然，这就增加了类与类之间的耦合。 ***JAVA是单线继承*** ，子类可以继承父类所有非私有成员，注意 ***构造器无法通过继承获取*** ，在构造子类对象时，会先构造父类对象。***成员属性的寻找顺序是：本类中寻找-->父类中寻找-->父类的父类-->......*** 一直向上寻找。而在继承中必须记住的是 **初始化顺序** （任何对象的初始化都会经历的2步）：
1）***加载类的顺序***：先加载父类，再加载子类，加载类的过程中，加载静态代码块和静态属性，加载的顺序就是他们的定义顺序。
2）***初始化对象***：先构造父类对象，再构造子类对象，初始化成员属性和构造块，初始化顺序是他们的定义顺序，最后走构造器。

```java
class A{	
}
class B extends A{	
}
class C extends B{	
}
/*加载类时，先A的静态块和静态属性，再B的静态块和静态属性，再C的静态块和静态属性；初始化对象时，先A的成员属性和构造块，再A的构造器；然后是B的成员属性和构造块，再B的构造器；最后C的成员属性和构造块，然后C的构造器*/
```

**代码块** 有三种：
1. 局部代码块：定义在方法内的代码块，为了隔离局部变量的作用域。
2. 构造代码块：直接定义在类中的代码块，为了在构造器之前执行。
3. 静态代码块：用static修饰的代码块，只在加载类的时候执行一次。

**static** 【关键字】
* 静态属性：属于类的，区别于成员属性（对象的）
* 静态方法：属于类的，可以用类名直接调用，不允许出现非静态的成员属性和方法
* 静态代码块
* 静态类：就是静态内部类
* 静态导入：已经不常用了

### 多态
***允许不同的对象对同一种消息做出响应***。这句话非常深奥，里面说的消息就是调用函数，即同一消息可以根据发送对象的不同而采用多种不同的行为方式。而多态有三个必要的条件：
* 要有继承
* 要有方法重写
* 要有父类引用子类对象

**向上转型**：父类引用子类对象，是一种安全的转型，缺点是不能使用子类独有的功能。
**向下转型**：子类引用父类引用，实际指向的是子类的对象，不安全的转型，可能会导致类型转换异常。

> 如果要保证部出现类型转换异常，必须要在转型之前***instanceof***判断

**final**【关键字】
* 修饰基本数据类型数据时，只能赋值一次，值不能再改变
* 修饰引用类型数据时，引用不能指向其它对象
* 修饰方法，表示方法不能被重写（覆盖）
* 修饰类，便是该类不能有子类，也就是不能被继承


## 抽象类和接口
既然把他们放在一起写，那么就先贴上他们的异同点：
**相同点：**
* 都不能被实例化
* 都能有抽象方法
* 子类继承都要实现所有的抽象方法，除非子类也是抽象的

**不同点：**
* 抽象类可以有构造器、成员属性和具体的方法，甚至可以有私有的成员
* 接口可以继承多个接口，类可以实现多个接口
* 接口在开发中往往作为一种规范使用，而抽象类是有多个具体的类抽象出来的


### 抽象类 abstract
***修饰方法：*** 说明这个方法是一个抽象方法，抽象方法没有方法体（没有实现过程）。专门用来给子类重写的，为了实现多态。
***修饰类：*** 说明该类是一个抽象类，抽象类里面可以声明抽象方法（普通的类里不能有抽象方法）。抽象类不能被实例化，专门用来被子类继承的，还是为了实现多态。
***注意亮点：1）继承一个抽象类必须覆盖抽象类中的所有抽象方法，除非这个子类也是一个抽象类。2）抽象类中可以有构造器，目地是为了强制子类为父类中的成员属性初始化。***


### 接口 interface

>多实现，多继承

接口就是一系列常量和抽象方法的集合。子类 **implements** 实现接口中所有的方法，接口不能被实例化，里面只能有常量和抽象方法。***常量默认可以省略`public final`，方法默认可以省略`public abstract`。接口可以继承多个接口，一个类可以实现多个接口。


## Object类
看API中的解释，知道这个类是java中所有类型的父类。 **Object** 除了默认的无参构造，拥有9个函数方法。也是最最主要的部分：
 1. **protected Object clone()**  --创建并返回此对象的一个副本。
 2. **boolean equals(Object obj)** --判断两个对象是否“相等。
	   - equals的默认实现就是`==`，本质就是判断2个引用是否指向同一个对象
	   - 可以通过重写equals方法修改它的实现过程（比较依据）
 3. **protected void finalize()** -- 回收垃圾引用。
    - 垃圾：没有引用指向的对象
    - 当这种对象被回收时，就会调用一次此方法
    - 可以通过重写这个方法，在对象被回收时，顺便回收一些别的垃圾对象
	很不建议这样做
 4. **Class<?> getClass()** --返回类对象 。
 5. **int hashCode()** --返回该对象的哈希码值。
    - 3个规定：
	    1. 同一个对象，多次调用hashCode结果【必须】一致
    	2. equals认为相等的对象，hashCode的结果【必须】一致
    	3. equals认为不相等的对象，hashCode的结果【最好】不一致

 6. **String toString()** --变成字符串，默认实现 `类名@哈希值`。
    - 往往可以通过重写这个方法，来打印出对象的成员属性的值，方便调试程序

 7. **void notify()**、 **void notifyAll()** 和 **void wait()** 都是在线程中使用的方法，具体可以看我线程部分的记录。

***注意：*** 只要重写了equals方法，第2个规定必然会不满足，所以重写equals必须也重写hashCode方法，使得其满足上述的条件2。
